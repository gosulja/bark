use super::decoders;
use super::decoders::*;
use super::misc;
use gpui::*;
use std::collections::HashMap;

pub struct BarkApp {
    input: String,                   /* Assembly input */
    output: Vec<Instruction>,        /* Output as instructions */
    decompiled: String,              /* Decompiled pseudo-c code */
    variables: HashMap<String, Var>, /* Variable map */
    next_var_id: usize,              /* Next placeholder id for the variable */
}

/* Helper for getting platform decoder, just for now return x86_64 / amd64 decoder */
fn get_platform_decoder(bytes: &[u8], addr: u64) -> Option<Instruction> {
    decoders::amd64::decode(bytes, addr)
}

impl BarkApp {
    pub fn new(_window: &mut Window, _cx: &mut Context<Self>) -> Self {
        let mut instance = Self {
            input: String::new(),
            output: Vec::new(),
            decompiled: String::new(),
            variables: HashMap::new(),
            next_var_id: 0,
        };

        /* Simple just explicitly load an "input.s" file (for debugging purposes.) */
        instance.load_file();
        instance
    }

    fn parse_bytes(&self, input: &str) -> Result<Vec<u8>, String> {
        /* Clean the input string so it can be effectively parsed */
        let cleaned = input.replace(" ", "").replace("0x", "");
        /*
            Validate the byte string to ensure it's a properly cleaned.
            We can achieve this by checking if it's an even length.
            because each byte is represented with two hex chars.
            2^n is always even.
        */
        if cleaned.len() % 2 != 0 {
            return Err("invalid byte input str length".to_string());
        }

        /*
            Create a new vector for the bytes to be pushed to.
        */
        let mut bytes = vec![];
        /* Iterare with two steps (bcus each byte is represented by 2) */
        for i in (0..cleaned.len()).step_by(2) {
            /* Substring two characters (the byte we want) */
            let bstr = &cleaned[i..i + 2];
            /* Convert to u8, if fails error. */
            match u8::from_str_radix(bstr, 16) {
                Ok(b) => bytes.push(b), /* Push to bytes vec */
                Err(_) => return Err(format!("invalid hex byte: {}", bstr)),
            }
        }

        /* Return bytes */
        Ok(bytes)
    }

    fn load_file(&mut self) {
        /* Explicitly read from the "input.s" file in the root directory. */
        match std::fs::read_to_string("input.s") {
            Ok(content) => {
                self.input = content.trim().to_string();
                /* Process each character to the input bff */
                self.process_input();
            }
            Err(_) => {
                eprintln!(
                    "[debug] if you see this error, it's because input.s does not exist in the root directory of the project."
                );
            }
        }
    }

    /*
        Decode instructions.

        For now, implementation for mov immediate to reg is implemented.
    */
    fn decode(&self, bytes: &[u8], addr: u64) -> Option<Instruction> {
        if bytes.is_empty() {
            return None;
        }

        get_platform_decoder(bytes, addr)
    }

    /* Simply generate a variable name */
    fn gen_var_name(&mut self) -> String {
        let name = format!("v{}", self.next_var_id);
        self.next_var_id += 1;
        name
    }

    fn decompile(&mut self) {
        /* Reset state */
        self.variables.clear();
        self.next_var_id = 0;

        let mut code = String::new();
        /*
            Boilerplate header set up and a fake entry point (temporary, just for the aesthetic of the decompilation output)
        */
        code.push_str("/* code generated by bark decompiler v0.1.0 */\n");
        code.push_str("#include <stdint.h>\n\n");
        code.push_str("void fn() {\n");

        for inst in self.output.clone() {
            /*
                Here, i only added decompilation support for
                the "mov" instruction.

                Check for the "mov" mnemonic, and if the operands len is 2, decompile it.
            */
            if inst.mnemonic == "mov" && inst.operands.len() == 2 {
                let reg = &inst.operands[0];
                let val = &inst.operands[1];

                /* Parse the immediate value */
                if let Ok(val) = if val.starts_with("0x") {
                    /* hexadecimal immediate */
                    i32::from_str_radix(&val[2..], 16)
                } else {
                    val.parse::<i32>() /* denary immediate */
                } {
                    /* Variable already exists? */
                    if let Some(var) = self.variables.get_mut(reg) {
                        var.value = val;
                        /* Push an assignment statement */
                        code.push_str(&format!("    {} = {};  /* {} */  \n", var.name, val, reg));
                    } else {
                        let vname = self.gen_var_name(); /* Generate a variable name */
                        let var = Var {
                            name: vname.clone(),
                            value: val,
                            register: reg.clone(),
                        }; /* Create the variable */

                        self.variables.insert(reg.clone(), var); /* Insert the variable at the register */
                        code.push_str(&format!(
                            "    int32_t {} = {};    /* {} */\n",
                            vname, val, reg
                        )); /* Push the variable decl to the code */
                    }
                }
            }
        }

        code.push_str("}\n");
        self.decompiled = code;
    }

    fn process_input(&mut self) {
        self.output.clear();

        if let Ok(bytes) = self.parse_bytes(&self.input) {
            let base_addr = 0x400000u64; /* Assume we start at 0x40000000 */
            let mut offset = 0; /* Offset (dependent on current instruction length in bytes) */

            while offset < bytes.len() {
                if let Some(inst) = self.decode(&bytes[offset..], base_addr + offset as u64) {
                    offset += inst.bytes.len();
                    self.output.push(inst);
                } else {
                    offset += 1;
                }
            }
        }

        self.decompile();
    }
}

impl Render for BarkApp {
    fn render(&mut self, _window: &mut Window, _cx: &mut Context<Self>) -> impl IntoElement {
        div()
            .flex()
            .flex_col()
            .size_full()
            .bg(rgb(0x1e1e1e))
            .text_color(rgb(0xffffff))
            .font_family("CaskaydiaCove Nerd Font")
            .child(
                div()
                    .text_sm()
                    .font_weight(FontWeight::BOLD)
                    .p_3()
                    .border_b_1()
                    .border_color(rgb(0x383838))
                    .child("bark disassembler"),
            )
            .child(
                div()
                    .flex()
                    .size_full()
                    .child(
                        div()
                            .flex()
                            .flex_col()
                            .w_1_2()
                            .border_color(rgb(0x383838))
                            .child(
                                div()
                                    .text_sm()
                                    .font_weight(FontWeight::SEMIBOLD)
                                    .p_2()
                                    .child("Disassembly"),
                            )
                            .child(
                                div()
                                    .flex_grow()
                                    .bg(rgb(0x282828))
                                    .border_1()
                                    .border_color(rgb(0x404040))
                                    .p_3()
                                    .text_sm()
                                    .children(self.output.iter().flat_map(|instr| {
                                        let line = format!(
                                            "0x{:08x}: {} {}",
                                            instr.addr,
                                            instr.mnemonic,
                                            instr.operands.join(", ")
                                        );

                                        vec![misc::do_highlight(&line, "asm")]
                                    })),
                            ),
                    )
                    .child(
                        div()
                            .flex()
                            .flex_col()
                            .w_1_2()
                            .child(
                                div()
                                    .text_sm()
                                    .font_weight(FontWeight::SEMIBOLD)
                                    .p_2()
                                    .child("Decompiler"),
                            )
                            .child(
                                div()
                                    .flex_grow()
                                    .bg(rgb(0x282828))
                                    .border_r_1()
                                    .border_b_1()
                                    .border_t_1()
                                    .border_color(rgb(0x404040))
                                    .font_family("CaskaydiaCove Nerd Font")
                                    .p_3()
                                    .text_sm()
                                    .children(
                                        self.decompiled
                                            .lines()
                                            .map(|line| misc::do_highlight(line, "c")),
                                    ),
                            ),
                    ),
            )
    }
}
